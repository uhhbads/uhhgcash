{"ast":null,"code":"\"use strict\";\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"direction\", \"theme\", \"linking\", \"fallback\", \"documentTitle\", \"onReady\", \"onStateChange\"];\nimport { BaseNavigationContainer, getActionFromState, getPathFromState, getStateFromPath, ThemeProvider, validatePathConfig } from '@react-navigation/core';\nimport * as React from 'react';\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport useLatestCallback from 'use-latest-callback';\nimport { LinkingContext } from \"./LinkingContext.js\";\nimport { LocaleDirContext } from \"./LocaleDirContext.js\";\nimport { DefaultTheme } from \"./theming/DefaultTheme.js\";\nimport { UnhandledLinkingContext } from \"./UnhandledLinkingContext.js\";\nimport { useBackButton } from './useBackButton';\nimport { useDocumentTitle } from './useDocumentTitle';\nimport { useLinking } from './useLinking';\nimport { useThenable } from \"./useThenable.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nglobalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();\nfunction NavigationContainerInner(_ref, ref) {\n  let {\n      direction = I18nManager.getConstants().isRTL ? 'rtl' : 'ltr',\n      theme = DefaultTheme,\n      linking,\n      fallback = null,\n      documentTitle,\n      onReady,\n      onStateChange\n    } = _ref,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const isLinkingEnabled = linking ? linking.enabled !== false : false;\n  if (linking?.config) {\n    validatePathConfig(linking.config);\n  }\n  const refContainer = React.useRef(null);\n  useBackButton(refContainer);\n  useDocumentTitle(refContainer, documentTitle);\n  const [lastUnhandledLink, setLastUnhandledLink] = React.useState();\n  const {\n    getInitialState\n  } = useLinking(refContainer, Object.assign({\n    enabled: isLinkingEnabled,\n    prefixes: []\n  }, linking), setLastUnhandledLink);\n  const linkingContext = React.useMemo(() => ({\n    options: linking\n  }), [linking]);\n  const unhandledLinkingContext = React.useMemo(() => ({\n    lastUnhandledLink,\n    setLastUnhandledLink\n  }), [lastUnhandledLink, setLastUnhandledLink]);\n  const onReadyForLinkingHandling = useLatestCallback(() => {\n    const path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink(previousLastUnhandledLink => {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onReady?.();\n  });\n  const onStateChangeForLinkingHandling = useLatestCallback(state => {\n    const path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink(previousLastUnhandledLink => {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onStateChange?.(state);\n  });\n  React.useEffect(() => {\n    if (refContainer.current) {\n      REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {\n        get linking() {\n          return Object.assign({}, linking, {\n            enabled: isLinkingEnabled,\n            prefixes: linking?.prefixes ?? [],\n            getStateFromPath: linking?.getStateFromPath ?? getStateFromPath,\n            getPathFromState: linking?.getPathFromState ?? getPathFromState,\n            getActionFromState: linking?.getActionFromState ?? getActionFromState\n          });\n        }\n      });\n    }\n  });\n  const [isResolved, initialState] = useThenable(getInitialState);\n  React.useImperativeHandle(ref, () => refContainer.current);\n  const isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;\n  if (!isLinkingReady) {\n    return _jsx(LocaleDirContext.Provider, {\n      value: direction,\n      children: _jsx(ThemeProvider, {\n        value: theme,\n        children: fallback\n      })\n    });\n  }\n  return _jsx(LocaleDirContext.Provider, {\n    value: direction,\n    children: _jsx(UnhandledLinkingContext.Provider, {\n      value: unhandledLinkingContext,\n      children: _jsx(LinkingContext.Provider, {\n        value: linkingContext,\n        children: _jsx(BaseNavigationContainer, Object.assign({}, rest, {\n          theme: theme,\n          onReady: onReadyForLinkingHandling,\n          onStateChange: onStateChangeForLinkingHandling,\n          initialState: rest.initialState == null ? initialState : rest.initialState,\n          ref: refContainer\n        }))\n      })\n    })\n  });\n}\nexport const NavigationContainer = React.forwardRef(NavigationContainerInner);","map":{"version":3,"names":["BaseNavigationContainer","getActionFromState","getPathFromState","getStateFromPath","ThemeProvider","validatePathConfig","React","I18nManager","useLatestCallback","LinkingContext","LocaleDirContext","DefaultTheme","UnhandledLinkingContext","useBackButton","useDocumentTitle","useLinking","useThenable","jsx","_jsx","globalThis","REACT_NAVIGATION_DEVTOOLS","WeakMap","NavigationContainerInner","_ref","ref","direction","getConstants","isRTL","theme","linking","fallback","documentTitle","onReady","onStateChange","rest","_objectWithoutPropertiesLoose","_excluded","isLinkingEnabled","enabled","config","refContainer","useRef","lastUnhandledLink","setLastUnhandledLink","useState","getInitialState","Object","assign","prefixes","linkingContext","useMemo","options","unhandledLinkingContext","onReadyForLinkingHandling","path","current","getCurrentRoute","previousLastUnhandledLink","undefined","onStateChangeForLinkingHandling","state","useEffect","set","isResolved","initialState","useImperativeHandle","isLinkingReady","Provider","value","children","NavigationContainer","forwardRef"],"sources":["D:\\CODE\\Aperture\\AG_cash\\mobile\\node_modules\\@react-navigation\\native\\src\\NavigationContainer.tsx"],"sourcesContent":["import {\n  BaseNavigationContainer,\n  getActionFromState,\n  getPathFromState,\n  getStateFromPath,\n  type NavigationContainerProps,\n  type NavigationContainerRef,\n  type NavigationState,\n  type ParamListBase,\n  ThemeProvider,\n  validatePathConfig,\n} from '@react-navigation/core';\nimport * as React from 'react';\nimport { I18nManager } from 'react-native';\nimport useLatestCallback from 'use-latest-callback';\n\nimport { LinkingContext } from './LinkingContext';\nimport { LocaleDirContext } from './LocaleDirContext';\nimport { DefaultTheme } from './theming/DefaultTheme';\nimport type {\n  DocumentTitleOptions,\n  LinkingOptions,\n  LocaleDirection,\n} from './types';\nimport { UnhandledLinkingContext } from './UnhandledLinkingContext';\nimport { useBackButton } from './useBackButton';\nimport { useDocumentTitle } from './useDocumentTitle';\nimport { useLinking } from './useLinking';\nimport { useThenable } from './useThenable';\n\ndeclare global {\n  var REACT_NAVIGATION_DEVTOOLS: WeakMap<\n    NavigationContainerRef<any>,\n    { readonly linking: LinkingOptions<any> }\n  >;\n}\n\nglobalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();\n\ntype Props<ParamList extends {}> = NavigationContainerProps & {\n  /**\n   * Initial state object for the navigation tree.\n   *\n   * If this is provided, deep link or URLs won't be handled on the initial render.\n   */\n  initialState?: NavigationContainerProps['initialState'];\n  /**\n   * Text direction of the components. Defaults to `'ltr'`.\n   */\n  direction?: LocaleDirection;\n  /**\n   * Options for deep linking.\n   *\n   * Deep link handling is enabled when this prop is provided,\n   * unless `linking.enabled` is `false`.\n   */\n  linking?: LinkingOptions<ParamList>;\n  /**\n   * Fallback element to render until initial state is resolved from deep linking.\n   *\n   * Defaults to `null`.\n   */\n  fallback?: React.ReactNode;\n  /**\n   * Options to configure the document title on Web.\n   *\n   * Updating document title is handled by default,\n   * unless `documentTitle.enabled` is `false`.\n   */\n  documentTitle?: DocumentTitleOptions;\n};\n\nfunction NavigationContainerInner(\n  {\n    direction = I18nManager.getConstants().isRTL ? 'rtl' : 'ltr',\n    theme = DefaultTheme,\n    linking,\n    fallback = null,\n    documentTitle,\n    onReady,\n    onStateChange,\n    ...rest\n  }: Props<ParamListBase>,\n  ref?: React.Ref<NavigationContainerRef<ParamListBase> | null>\n) {\n  const isLinkingEnabled = linking ? linking.enabled !== false : false;\n\n  if (linking?.config) {\n    validatePathConfig(linking.config);\n  }\n\n  const refContainer =\n    React.useRef<NavigationContainerRef<ParamListBase>>(null);\n\n  useBackButton(refContainer);\n  useDocumentTitle(refContainer, documentTitle);\n\n  const [lastUnhandledLink, setLastUnhandledLink] = React.useState<\n    string | undefined\n  >();\n\n  const { getInitialState } = useLinking(\n    refContainer,\n    {\n      enabled: isLinkingEnabled,\n      prefixes: [],\n      ...linking,\n    },\n    setLastUnhandledLink\n  );\n\n  const linkingContext = React.useMemo(() => ({ options: linking }), [linking]);\n\n  const unhandledLinkingContext = React.useMemo(\n    () => ({ lastUnhandledLink, setLastUnhandledLink }),\n    [lastUnhandledLink, setLastUnhandledLink]\n  );\n\n  const onReadyForLinkingHandling = useLatestCallback(() => {\n    // If the screen path matches lastUnhandledLink, we do not track it\n    const path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink((previousLastUnhandledLink) => {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onReady?.();\n  });\n\n  const onStateChangeForLinkingHandling = useLatestCallback(\n    (state: Readonly<NavigationState> | undefined) => {\n      // If the screen path matches lastUnhandledLink, we do not track it\n      const path = refContainer.current?.getCurrentRoute()?.path;\n      setLastUnhandledLink((previousLastUnhandledLink) => {\n        if (previousLastUnhandledLink === path) {\n          return undefined;\n        }\n        return previousLastUnhandledLink;\n      });\n      onStateChange?.(state);\n    }\n  );\n  // Add additional linking related info to the ref\n  // This will be used by the devtools\n  React.useEffect(() => {\n    if (refContainer.current) {\n      REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {\n        get linking() {\n          return {\n            ...linking,\n            enabled: isLinkingEnabled,\n            prefixes: linking?.prefixes ?? [],\n            getStateFromPath: linking?.getStateFromPath ?? getStateFromPath,\n            getPathFromState: linking?.getPathFromState ?? getPathFromState,\n            getActionFromState:\n              linking?.getActionFromState ?? getActionFromState,\n          };\n        },\n      });\n    }\n  });\n\n  const [isResolved, initialState] = useThenable(getInitialState);\n\n  // FIXME\n  // @ts-expect-error not sure why this is not working\n  React.useImperativeHandle(ref, () => refContainer.current);\n\n  const isLinkingReady =\n    rest.initialState != null || !isLinkingEnabled || isResolved;\n\n  if (!isLinkingReady) {\n    return (\n      <LocaleDirContext.Provider value={direction}>\n        <ThemeProvider value={theme}>{fallback}</ThemeProvider>\n      </LocaleDirContext.Provider>\n    );\n  }\n\n  return (\n    <LocaleDirContext.Provider value={direction}>\n      <UnhandledLinkingContext.Provider value={unhandledLinkingContext}>\n        <LinkingContext.Provider value={linkingContext}>\n          <BaseNavigationContainer\n            {...rest}\n            theme={theme}\n            onReady={onReadyForLinkingHandling}\n            onStateChange={onStateChangeForLinkingHandling}\n            initialState={\n              rest.initialState == null ? initialState : rest.initialState\n            }\n            ref={refContainer}\n          />\n        </LinkingContext.Provider>\n      </UnhandledLinkingContext.Provider>\n    </LocaleDirContext.Provider>\n  );\n}\n\n/**\n * Container component that manages the navigation state.\n * This should be rendered at the root wrapping the whole app.\n */\nexport const NavigationContainer = React.forwardRef(\n  NavigationContainerInner\n) as <RootParamList extends {} = ReactNavigation.RootParamList>(\n  props: Props<RootParamList> & {\n    ref?: React.Ref<NavigationContainerRef<RootParamList>>;\n  }\n) => React.ReactElement;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}