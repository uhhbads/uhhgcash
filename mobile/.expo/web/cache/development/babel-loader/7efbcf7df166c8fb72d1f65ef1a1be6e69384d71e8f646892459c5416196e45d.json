{"ast":null,"code":"\"use strict\";\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"screen\", \"if\"],\n  _excluded2 = [\"screens\", \"groups\"],\n  _excluded3 = [\"if\"];\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\nimport { useRoute } from \"./useRoute.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MemoizedScreen = React.memo(({\n  component\n}) => {\n  const route = useRoute();\n  const children = React.createElement(component, {\n    route\n  });\n  return children;\n});\nMemoizedScreen.displayName = 'Memo(Screen)';\nconst getItemsFromScreens = (Screen, screens) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component;\n    let props = {};\n    let useIf;\n    let isNavigator = false;\n    if ('screen' in item) {\n      const {\n          screen,\n          if: _if\n        } = item,\n        rest = _objectWithoutPropertiesLoose(item, _excluded);\n      useIf = _if;\n      props = rest;\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, `${name}Navigator`);\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n    if (component == null) {\n      throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n    }\n    const element = isNavigator ? (React.createElement(component, {})) : _jsx(MemoizedScreen, {\n      component: component\n    });\n    return () => {\n      const shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return _jsx(Screen, Object.assign({\n        name: name\n      }, props, {\n        children: () => element\n      }), name);\n    };\n  });\n};\nexport function createComponentForStaticNavigation(tree, displayName) {\n  const {\n    Navigator,\n    Group,\n    Screen,\n    config\n  } = tree;\n  const {\n      screens,\n      groups\n    } = config,\n    rest = _objectWithoutPropertiesLoose(config, _excluded2);\n  if (screens == null && groups == null) {\n    throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");\n  }\n  const items = [];\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n    if (key === 'groups' && groups) {\n      items.push(...Object.entries(groups).map(([key, _ref]) => {\n        let {\n            if: useIf\n          } = _ref,\n          group = _objectWithoutPropertiesLoose(_ref, _excluded3);\n        const groupItems = getItemsFromScreens(Screen, group.screens);\n        return () => {\n          const children = groupItems.map(item => item());\n          const shouldRender = useIf == null || useIf();\n          if (!shouldRender) {\n            return null;\n          }\n          return _jsx(Group, Object.assign({\n            navigationKey: key\n          }, group, {\n            children: children\n          }), key);\n        };\n      }));\n    }\n  }\n  const NavigatorComponent = () => {\n    const children = items.map(item => item());\n    return _jsx(Navigator, Object.assign({}, rest, {\n      children: children\n    }));\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\nexport function createPathConfigForStaticNavigation(tree, options, auto) {\n  let initialScreenHasPath = false;\n  let initialScreenConfig;\n  const createPathConfigForTree = (t, o, skipInitialDetection) => {\n    const createPathConfigForScreens = (screens, initialRouteName) => {\n      return Object.fromEntries(Object.entries(screens).sort(([a], [b]) => {\n        if (a === initialRouteName) {\n          return -1;\n        }\n        if (b === initialRouteName) {\n          return 1;\n        }\n        return 0;\n      }).map(([key, item]) => {\n        const screenConfig = {};\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n          if (typeof screenConfig.path === 'string') {\n            screenConfig.path = screenConfig.path.replace(/^\\//, '').replace(/\\/$/, '');\n          }\n        }\n        let screens;\n        const skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';\n        if ('config' in item) {\n          screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);\n        } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {\n          screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);\n        }\n        if (screens) {\n          screenConfig.screens = screens;\n        }\n        if (auto && !screenConfig.screens && !('linking' in item && item.linking == null)) {\n          if (screenConfig.path != null) {\n            if (!skipInitialDetection) {\n              if (key === initialRouteName && screenConfig.path != null) {\n                initialScreenHasPath = true;\n              } else if (screenConfig.path === '') {\n                initialScreenConfig = undefined;\n              }\n            }\n          } else {\n            if (!skipInitialDetection && initialScreenConfig == null) {\n              initialScreenConfig = screenConfig;\n            }\n            screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();\n          }\n        }\n        return [key, screenConfig];\n      }).filter(([, screen]) => Object.keys(screen).length > 0));\n    };\n    const screens = {};\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(screens, createPathConfigForScreens(t.config.screens, o?.initialRouteName ?? t.config.initialRouteName));\n      }\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(screens, createPathConfigForScreens(group.screens, o?.initialRouteName ?? t.config.initialRouteName));\n        });\n      }\n    }\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n    return screens;\n  };\n  const screens = createPathConfigForTree(tree, options, false);\n  if (auto && initialScreenConfig && !initialScreenHasPath) {\n    initialScreenConfig.path = '';\n  }\n  return screens;\n}","map":{"version":3,"names":["React","isValidElementType","useRoute","jsx","_jsx","MemoizedScreen","memo","component","route","children","createElement","displayName","getItemsFromScreens","Screen","screens","Object","entries","map","name","item","props","useIf","isNavigator","screen","if","_if","rest","_objectWithoutPropertiesLoose","_excluded","createComponentForStaticNavigation","Error","element","shouldRender","assign","tree","Navigator","Group","config","groups","_excluded2","items","key","push","_ref","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenHasPath","initialScreenConfig","createPathConfigForTree","t","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","a","b","screenConfig","linking","path","replace","skipInitialDetectionInChild","undefined","toLowerCase","filter","keys","length","forEach"],"sources":["D:\\CODE\\Aperture\\AG_cash\\mobile\\node_modules\\@react-navigation\\core\\src\\StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  RouteName,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\nexport type StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\nexport type StaticConfigGroup<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: StaticConfigGroup<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: StaticConfigGroup<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => React.JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group key={key} navigationKey={key} {...group}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenHasPath: boolean = false;\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n\n              if (typeof screenConfig.path === 'string') {\n                screenConfig.path = screenConfig.path\n                  .replace(/^\\//, '') // Remove extra leading slash\n                  .replace(/\\/$/, ''); // Remove extra trailing slash\n              }\n            }\n\n            let screens;\n\n            const skipInitialDetectionInChild =\n              skipInitialDetection ||\n              (screenConfig.path != null && screenConfig.path !== '');\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (\n              auto &&\n              !screenConfig.screens &&\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n              !('linking' in item && item.linking == null)\n            ) {\n              if (screenConfig.path != null) {\n                if (!skipInitialDetection) {\n                  if (key === initialRouteName && screenConfig.path != null) {\n                    initialScreenHasPath = true;\n                  } else if (screenConfig.path === '') {\n                    // We encounter a leaf screen with empty path,\n                    // Clear the initial screen config as it's not needed anymore\n                    initialScreenConfig = undefined;\n                  }\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig && !initialScreenHasPath) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}